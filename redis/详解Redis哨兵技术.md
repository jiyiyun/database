redis高可用相关技术
- 持久化Persistence

持久化是简单的高可用方法，作用是将数据备份，将数据存储在硬盘，保证进程退出数据不丢失

- 复制 Replication

复制是高可用redis的基础，哨兵和集群都是在复制的基础上实现高可用的，复制实现了数据多机备份，对于读写操作的负载均衡和简单的故障恢复，缺陷是故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机限制

- 哨兵Sentinel

在复制的基础之上，哨兵实现了自动化故障恢复。缺陷是写操作无法负载均衡，存储能力受到单机限制

- 集群 Cluster

通过集群，redis解决了写操作无法负载均衡，以及存储能力受到单机限制的问题，实现了较为完善的高可用方案

哨兵功能描述：
- 监控Monitoring :哨兵会不断检查主节点和从节点是否工作正常
- 自动故障迁移 Automatic Failover ：当主节点不能正常工作的时候，哨兵会自动故障迁移操作，它会将失效节点的其中一个从节点升级为新的主节点。
- 配置提供者 configuration ：客户端在初始化时，通过连接哨兵来获得当前redis服务的主节点地址
- 通知 Notification ：哨兵可以将故障转移的结果发送给客户端

哨兵架构包括：
- 哨兵节点： 哨兵系统由一个或者多个哨兵节点组成，哨兵节点是特殊的redis节点，不保存数据。
- 数据节点：主节点和从节点都是数据节点

部署Sentinel(简单的哨兵系统1主2从3哨兵)
---

1. 部署主从节点
哨兵系统的主从节点与普通的主从节点配置是一样的，并不需要做任何额外配置，下面分别用主port=6381，从port=6382/6383的配置文件

```txt
#redis-6381.conf  
port 6381
daemonize yes  
logfile "6381.log"  
dbfilename "dump-6381.rdb" 
 
#redis-6382.conf  
port 6382
daemonize yes  
logfile "6382.log"  
dbfilename "dump-6382.rdb"  
slaveof 127.0.0.1 6381  

#redis-6383.conf
port 6383
daemonize yes  
logfile "6383.log"  
dbfilename "dump-6383.rdb"  
slaveof 127.0.0.1 6381
```

配置完成后，依次启动主从节点

```txt
redis-server redis-6381.conf
redis-server redis-6382.conf
redis-server redis-6383.conf
```
节点启动后检查是否启动正常

```txt
redis-cli -p 6381
127.0.0.1:6381> info replication
# Replication
role:master
connected_slaves:2
slave0:ip=127.0.0.1,port=6382,state=online,offset=155,lag=1
slave1:ip=127.0.0.1,port=6383,state=online,offset=155,lag=0
master_repl_offset:155
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:2
repl_backlog_histlen:154
```

部署哨兵节点Sentinel(哨兵节点本质上是特殊redis节点)
---

3个哨兵节点的配置几乎一样，只有端口号不同

```txt
#sentinel-26381.conf  
port 26381
daemonize yes  
logfile "26381.log"  
sentinel monitor mymaster 127.0.0.1 6381 2

#sentinel-26382.conf  
port 26382
daemonize yes  
logfile "26382.log"  
sentinel monitor mymaster 127.0.0.1 6381 2

#sentinel-26383.conf  
port 26383
daemonize yes  
logfile "26383.log"  
sentinel monitor mymaster 127.0.0.1 6381 2
```

sentinel monitor mymaster 127.0.0.1 6381 2配置的含义是：该哨兵节点监控127.0.0.1 6381这个主节点，该主节点名称是mymaster,最后的2与故障判定有关：知识需要2个哨兵节点同意，才能判定主节点故障并进行故障迁移。

启动哨兵节点的两种方式：
- redis-sentinel sentinel-26381.conf
- redis-server sentinel-26381.conf --sentinel
```

连接上去验证
---

```txt
127.0.0.1:26381> info sentinel
# Sentinel
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0
master0:name=mymaster,status=ok,address=127.0.0.1:6381,slaves=2,sentinels=3
```
看到sentinel=3,3个哨兵都发现了

检查sentinel-26381.conf 多出几行

```txt
# Generated by CONFIG REWRITE
sentinel monitor mymaster 127.0.0.1 6381 2
sentinel config-epoch mymaster 0
sentinel leader-epoch mymaster 0
sentinel known-slave mymaster 127.0.0.1 6383
sentinel known-slave mymaster 127.0.0.1 6382
sentinel known-sentinel mymaster 127.0.0.1 26383 1cafd878e8cee44aab4b2adb223d4aef966a46d1
sentinel known-sentinel mymaster 127.0.0.1 26382 fdec2d8cf837dc3fd7165e9d3873edf6bf8bd27b
sentinel current-epoch 0
```
know-slave和know-sentinel显示已经发现了其它哨兵，epoch参数与配置纪元有关(配置纪元是从0开始的计时器，从0开始，每进行选举一次自+1)

演示故障迁移
---

step 1 shutdown 掉主节点

redis-cli -p 6381 shutdown

step 2 如果立即用infor Sentinel命令查看会发现主节点还没切换过来，因为哨兵发现故障并转移需要时间

step 3 一段时间后查看，主节点已经切换成为其它节点
```txt
$ tail 26383/sentinel-26383.conf 
sentinel myid 1cafd878e8cee44aab4b2adb223d4aef966a46d1
# Generated by CONFIG REWRITE
sentinel monitor mymaster 127.0.0.1 6383 2
sentinel config-epoch mymaster 1
sentinel leader-epoch mymaster 1
sentinel known-slave mymaster 127.0.0.1 6382
sentinel known-slave mymaster 127.0.0.1 6381
sentinel known-sentinel mymaster 127.0.0.1 26382 fdec2d8cf837dc3fd7165e9d3873edf6bf8bd27b
sentinel known-sentinel mymaster 127.0.0.1 26381 fd0b51d10d1d9a0de3232b9bc50bb72ac6b208f0
sentinel current-epoch 1
```
step 4 原来的主节点再次启动后，会变成从节点

```txt
redis-server 6381/redis.conf
$ tail 26381/sentinel-26381.conf 
sentinel myid fd0b51d10d1d9a0de3232b9bc50bb72ac6b208f0
# Generated by CONFIG REWRITE
sentinel monitor mymaster 127.0.0.1 6383 2
sentinel config-epoch mymaster 1
sentinel leader-epoch mymaster 1
sentinel known-slave mymaster 127.0.0.1 6382
sentinel known-slave mymaster 127.0.0.1 6381
sentinel known-sentinel mymaster 127.0.0.1 26383 1cafd878e8cee44aab4b2adb223d4aef966a46d1
sentinel known-sentinel mymaster 127.0.0.1 26382 fdec2d8cf837dc3fd7165e9d3873edf6bf8bd27b
sentinel current-epoch 1
```
step 5 在故障迁移阶段，哨兵和主节点的配置文件都会改写

对于主从节点，主要是slaveof配置的变化；新的主节点没有了slaveof的配置，从节点则slaveof新的主节点

对于哨兵节点，除了主从节点信息变化，纪元spoch也在变化，每次选举一次+1

总结sentinel
---

哨兵系统的搭建过程几点要注意：
1. 哨兵系统的主从节点，与普通的主从节点并没有太大区别，故障发现和转移由哨兵来控制和完成的
2. 哨兵节点本质上是redis节点
3. 每个哨兵节点，只需配置监控主节点，便可以自动发现其它从节点和哨兵节点
4. 在哨兵节点启动和故障迁移阶段，各个节点的配置文件会被重写(rewrite)
5. 本实例中，一个哨兵只监控了1个主节点，一个哨兵节点可以监控多个主节点，通过Sentinel monitor实现

基础查询
---

- info sentinel
- sentinel masters
- sentinel master MASTER_NAME
- sentinel slaves MASTER_NAME
- sentinel sentinels MASTER_NAME
- sentinel get - master -add -by -name MASTER_NAME
- sentinel is -master-down-by-addr

增加/移除对主节点的监控
- sentinel monitor MASTER2 IP PORT 2
- sentinel remove MASTER2

强制故障迁移(主机要down或者其它原因)
- sentinel failover MASTER

sentinel配置与实践建议
---

配置1：sentinel monitor {masterName} {masterIp} {masterPort} {quorum}

sentinel monitor是哨兵最核心的配置，在前文讲述部署哨兵节点时已说明，其中：masterName指定了主节点名称，masterIp和masterPort指定了主节点地址，quorum是判断主节点客观下线的哨兵数量阈值：当判定主节点下线的哨兵数量达到quorum时，对主节点进行客观下线。建议取值为哨兵数量的一半加1。

配置2：sentinel down-after-milliseconds {masterName} {time}

sentinel down-after-milliseconds与主观下线的判断有关：哨兵使用ping命令对其他节点进行心跳检测，如果其他节点超过down-after-milliseconds配置的时间没有回复，哨兵就会将其进行主观下线。该配置对主节点、从节点和哨兵节点的主观下线判定都有效。

down-after-milliseconds的默认值是30000，即30s；可以根据不同的网络环境和应用要求来调整：值越大，对主观下线的判定会越宽松，好处是误判的可能性小，坏处是故障发现和故障转移的时间变长，客户端等待的时间也会变长。例如，如果应用对可用性要求较高，则可以将值适当调小，当故障发生时尽快完成转移；如果网络环境相对较差，可以适当提高该阈值，避免频繁误判。

配置3：sentinel parallel - syncs {masterName} {number}

sentinel parallel-syncs与故障转移之后从节点的复制有关：它规定了每次向新的主节点发起复制操作的从节点个数。例如，假设主节点切换完成之后，有3个从节点要向新的主节点发起复制；如果parallel-syncs=1，则从节点会一个一个开始复制；如果parallel-syncs=3，则3个从节点会一起开始复制。

parallel-syncs取值越大，从节点完成复制的时间越快，但是对主节点的网络负载、硬盘负载造成的压力也越大；应根据实际情况设置。例如，如果主节点的负载较低，而从节点对服务可用的要求较高，可以适量增加parallel-syncs取值。parallel-syncs的默认值是1。

配置4：sentinel failover - timeout {masterName} {time}

sentinel failover-timeout与故障转移超时的判断有关，但是该参数不是用来判断整个故障转移阶段的超时，而是其几个子阶段的超时，例如如果主节点晋升从节点时间超过timeout，或从节点向新的主节点发起复制操作的时间（不包括复制数据的时间）超过timeout，都会导致故障转移超时失败。

failover-timeout的默认值是180000，即180s；如果超时，则下一次该值会变为原来的2倍。

配置5：除上述几个参数外，还有一些其他参数，如安全验证相关的参数，这里不做介绍。

2.实践建议

哨兵节点的数量应不止一个。一方面增加哨兵节点的冗余，避免哨兵本身成为高可用的瓶颈；另一方面减少对下线的误判。此外，这些不同的哨兵节点应部署在不同的物理机上。

哨兵节点的数量应该是奇数，便于哨兵通过投票做出“决策”：领导者选举的决策、客观下线的决策等。

各个哨兵节点的配置应一致，包括硬件、参数等；此外，所有节点都应该使用ntp或类似服务，保证时间准确、一致。

哨兵的配置提供者和通知客户端功能，需要客户端的支持才能实现，如前文所说的Jedis；如果开发者使用的库未提供相应支持，则可能需要开发者自己实现。

当哨兵系统中的节点在Docker（或其他可能进行端口映射的软件）中部署时，应特别注意端口映射可能会导致哨兵系统无法正常工作，因为哨兵的工作基于与其他节点的通信，而Docker的端口映射可能导致哨兵无法连接到其他节点。例如，哨兵之间互相发现，依赖于它们对外宣称的IP和port，如果某个哨兵A部署在做了端口映射的Docker中，那么其他哨兵使用A宣称的port无法连接到A。

六、总结

本文首先介绍了哨兵的作用：监控、故障转移、配置提供者和通知；然后讲述了哨兵系统的部署方法，以及通过客户端访问哨兵系统的方法；再然后简要说明了哨兵实现的基本原理；最后给出了关于哨兵实践的一些建议。

在主从复制的基础上，哨兵引入了主节点的自动故障转移，进一步提高了Redis的高可用性；但是哨兵的缺陷同样很明显：哨兵无法对从节点进行自动故障转移，在读写分离场景下，从节点故障会导致读服务不可用，需要我们对从节点做额外的监控、切换操作。

此外，哨兵仍然没有解决写操作无法负载均衡、及存储能力受到单机限制的问题；这些问题的解决需要使用集群，欢迎关注社群后续内容。

参考

https://redis.io/topics/sentinel

http://www.redis.cn/

《Redis开发与运维》








来源： 
- http://database.51cto.com/art/201811/586105.htm
- https://www.toutiao.com/a6618727415893983758/